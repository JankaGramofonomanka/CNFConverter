-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module FromBNFC.ParQFBF where
import FromBNFC.AbsQFBF
import FromBNFC.LexQFBF
import FromBNFC.ErrM

}

%name pFormula Formula
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '<==' { PT _ (TS _ 3) }
  '<=>' { PT _ (TS _ 4) }
  '==>' { PT _ (TS _ 5) }
  'and' { PT _ (TS _ 6) }
  'not' { PT _ (TS _ 7) }
  'or' { PT _ (TS _ 8) }
  'xor' { PT _ (TS _ 9) }

L_ident  { PT _ (TV $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }

Formula1 :: { Formula }
Formula1 : Formula2 '<=>' Formula2 { FromBNFC.AbsQFBF.Equ $1 $3 }
         | Formula2 { $1 }
Formula2 :: { Formula }
Formula2 : Formula3 '==>' Formula3 { FromBNFC.AbsQFBF.RImpl $1 $3 }
         | Formula3 '<==' Formula3 { FromBNFC.AbsQFBF.LImpl $1 $3 }
         | Formula3 { $1 }
Formula3 :: { Formula }
Formula3 : Formula4 'and' Formula4 { FromBNFC.AbsQFBF.And $1 $3 }
         | Formula4 { $1 }
Formula4 :: { Formula }
Formula4 : Formula5 'or' Formula5 { FromBNFC.AbsQFBF.Or $1 $3 }
         | Formula5 'xor' Formula5 { FromBNFC.AbsQFBF.XOr $1 $3 }
         | Formula5 { $1 }
Formula5 :: { Formula }
Formula5 : 'not' Formula6 { FromBNFC.AbsQFBF.Not $2 }
         | Formula6 { $1 }
Formula6 :: { Formula }
Formula6 : Ident { FromBNFC.AbsQFBF.Var $1 }
         | '(' Formula ')' { $2 }
Formula :: { Formula }
Formula : Formula1 { $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

